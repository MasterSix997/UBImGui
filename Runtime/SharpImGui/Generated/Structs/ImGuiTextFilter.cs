using System;
using UnityEngine;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Text;

namespace SharpImGui
{
	/// <summary>
	/// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		public byte InputBuf_0;
		public byte InputBuf_1;
		public byte InputBuf_2;
		public byte InputBuf_3;
		public byte InputBuf_4;
		public byte InputBuf_5;
		public byte InputBuf_6;
		public byte InputBuf_7;
		public byte InputBuf_8;
		public byte InputBuf_9;
		public byte InputBuf_10;
		public byte InputBuf_11;
		public byte InputBuf_12;
		public byte InputBuf_13;
		public byte InputBuf_14;
		public byte InputBuf_15;
		public byte InputBuf_16;
		public byte InputBuf_17;
		public byte InputBuf_18;
		public byte InputBuf_19;
		public byte InputBuf_20;
		public byte InputBuf_21;
		public byte InputBuf_22;
		public byte InputBuf_23;
		public byte InputBuf_24;
		public byte InputBuf_25;
		public byte InputBuf_26;
		public byte InputBuf_27;
		public byte InputBuf_28;
		public byte InputBuf_29;
		public byte InputBuf_30;
		public byte InputBuf_31;
		public byte InputBuf_32;
		public byte InputBuf_33;
		public byte InputBuf_34;
		public byte InputBuf_35;
		public byte InputBuf_36;
		public byte InputBuf_37;
		public byte InputBuf_38;
		public byte InputBuf_39;
		public byte InputBuf_40;
		public byte InputBuf_41;
		public byte InputBuf_42;
		public byte InputBuf_43;
		public byte InputBuf_44;
		public byte InputBuf_45;
		public byte InputBuf_46;
		public byte InputBuf_47;
		public byte InputBuf_48;
		public byte InputBuf_49;
		public byte InputBuf_50;
		public byte InputBuf_51;
		public byte InputBuf_52;
		public byte InputBuf_53;
		public byte InputBuf_54;
		public byte InputBuf_55;
		public byte InputBuf_56;
		public byte InputBuf_57;
		public byte InputBuf_58;
		public byte InputBuf_59;
		public byte InputBuf_60;
		public byte InputBuf_61;
		public byte InputBuf_62;
		public byte InputBuf_63;
		public byte InputBuf_64;
		public byte InputBuf_65;
		public byte InputBuf_66;
		public byte InputBuf_67;
		public byte InputBuf_68;
		public byte InputBuf_69;
		public byte InputBuf_70;
		public byte InputBuf_71;
		public byte InputBuf_72;
		public byte InputBuf_73;
		public byte InputBuf_74;
		public byte InputBuf_75;
		public byte InputBuf_76;
		public byte InputBuf_77;
		public byte InputBuf_78;
		public byte InputBuf_79;
		public byte InputBuf_80;
		public byte InputBuf_81;
		public byte InputBuf_82;
		public byte InputBuf_83;
		public byte InputBuf_84;
		public byte InputBuf_85;
		public byte InputBuf_86;
		public byte InputBuf_87;
		public byte InputBuf_88;
		public byte InputBuf_89;
		public byte InputBuf_90;
		public byte InputBuf_91;
		public byte InputBuf_92;
		public byte InputBuf_93;
		public byte InputBuf_94;
		public byte InputBuf_95;
		public byte InputBuf_96;
		public byte InputBuf_97;
		public byte InputBuf_98;
		public byte InputBuf_99;
		public byte InputBuf_100;
		public byte InputBuf_101;
		public byte InputBuf_102;
		public byte InputBuf_103;
		public byte InputBuf_104;
		public byte InputBuf_105;
		public byte InputBuf_106;
		public byte InputBuf_107;
		public byte InputBuf_108;
		public byte InputBuf_109;
		public byte InputBuf_110;
		public byte InputBuf_111;
		public byte InputBuf_112;
		public byte InputBuf_113;
		public byte InputBuf_114;
		public byte InputBuf_115;
		public byte InputBuf_116;
		public byte InputBuf_117;
		public byte InputBuf_118;
		public byte InputBuf_119;
		public byte InputBuf_120;
		public byte InputBuf_121;
		public byte InputBuf_122;
		public byte InputBuf_123;
		public byte InputBuf_124;
		public byte InputBuf_125;
		public byte InputBuf_126;
		public byte InputBuf_127;
		public byte InputBuf_128;
		public byte InputBuf_129;
		public byte InputBuf_130;
		public byte InputBuf_131;
		public byte InputBuf_132;
		public byte InputBuf_133;
		public byte InputBuf_134;
		public byte InputBuf_135;
		public byte InputBuf_136;
		public byte InputBuf_137;
		public byte InputBuf_138;
		public byte InputBuf_139;
		public byte InputBuf_140;
		public byte InputBuf_141;
		public byte InputBuf_142;
		public byte InputBuf_143;
		public byte InputBuf_144;
		public byte InputBuf_145;
		public byte InputBuf_146;
		public byte InputBuf_147;
		public byte InputBuf_148;
		public byte InputBuf_149;
		public byte InputBuf_150;
		public byte InputBuf_151;
		public byte InputBuf_152;
		public byte InputBuf_153;
		public byte InputBuf_154;
		public byte InputBuf_155;
		public byte InputBuf_156;
		public byte InputBuf_157;
		public byte InputBuf_158;
		public byte InputBuf_159;
		public byte InputBuf_160;
		public byte InputBuf_161;
		public byte InputBuf_162;
		public byte InputBuf_163;
		public byte InputBuf_164;
		public byte InputBuf_165;
		public byte InputBuf_166;
		public byte InputBuf_167;
		public byte InputBuf_168;
		public byte InputBuf_169;
		public byte InputBuf_170;
		public byte InputBuf_171;
		public byte InputBuf_172;
		public byte InputBuf_173;
		public byte InputBuf_174;
		public byte InputBuf_175;
		public byte InputBuf_176;
		public byte InputBuf_177;
		public byte InputBuf_178;
		public byte InputBuf_179;
		public byte InputBuf_180;
		public byte InputBuf_181;
		public byte InputBuf_182;
		public byte InputBuf_183;
		public byte InputBuf_184;
		public byte InputBuf_185;
		public byte InputBuf_186;
		public byte InputBuf_187;
		public byte InputBuf_188;
		public byte InputBuf_189;
		public byte InputBuf_190;
		public byte InputBuf_191;
		public byte InputBuf_192;
		public byte InputBuf_193;
		public byte InputBuf_194;
		public byte InputBuf_195;
		public byte InputBuf_196;
		public byte InputBuf_197;
		public byte InputBuf_198;
		public byte InputBuf_199;
		public byte InputBuf_200;
		public byte InputBuf_201;
		public byte InputBuf_202;
		public byte InputBuf_203;
		public byte InputBuf_204;
		public byte InputBuf_205;
		public byte InputBuf_206;
		public byte InputBuf_207;
		public byte InputBuf_208;
		public byte InputBuf_209;
		public byte InputBuf_210;
		public byte InputBuf_211;
		public byte InputBuf_212;
		public byte InputBuf_213;
		public byte InputBuf_214;
		public byte InputBuf_215;
		public byte InputBuf_216;
		public byte InputBuf_217;
		public byte InputBuf_218;
		public byte InputBuf_219;
		public byte InputBuf_220;
		public byte InputBuf_221;
		public byte InputBuf_222;
		public byte InputBuf_223;
		public byte InputBuf_224;
		public byte InputBuf_225;
		public byte InputBuf_226;
		public byte InputBuf_227;
		public byte InputBuf_228;
		public byte InputBuf_229;
		public byte InputBuf_230;
		public byte InputBuf_231;
		public byte InputBuf_232;
		public byte InputBuf_233;
		public byte InputBuf_234;
		public byte InputBuf_235;
		public byte InputBuf_236;
		public byte InputBuf_237;
		public byte InputBuf_238;
		public byte InputBuf_239;
		public byte InputBuf_240;
		public byte InputBuf_241;
		public byte InputBuf_242;
		public byte InputBuf_243;
		public byte InputBuf_244;
		public byte InputBuf_245;
		public byte InputBuf_246;
		public byte InputBuf_247;
		public byte InputBuf_248;
		public byte InputBuf_249;
		public byte InputBuf_250;
		public byte InputBuf_251;
		public byte InputBuf_252;
		public byte InputBuf_253;
		public byte InputBuf_254;
		public byte InputBuf_255;
		public ImVector<ImGuiTextRange> Filters;
		public int CountGrep;
	}

	/// <summary>
	/// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"<br/>
	/// </summary>
	public unsafe partial struct ImGuiTextFilterPtr
	{
		public ImGuiTextFilter* NativePtr { get; }
		public bool IsNull => NativePtr == null;
		public ImGuiTextFilter this[int index] { get => NativePtr[index]; set => NativePtr[index] = value; }
		public Span<byte> InputBuf => new Span<byte>(&NativePtr->InputBuf_0, 256);
		public ref ImVector<ImGuiTextRange> Filters => ref Unsafe.AsRef<ImVector<ImGuiTextRange>>(&NativePtr->Filters);
		public ref int CountGrep => ref Unsafe.AsRef<int>(&NativePtr->CountGrep);
		public ImGuiTextFilterPtr(ImGuiTextFilter* nativePtr) => NativePtr = nativePtr;
		public ImGuiTextFilterPtr(IntPtr nativePtr) => NativePtr = (ImGuiTextFilter*)nativePtr;
		public static implicit operator ImGuiTextFilterPtr(ImGuiTextFilter* ptr) => new ImGuiTextFilterPtr(ptr);
		public static implicit operator ImGuiTextFilterPtr(IntPtr ptr) => new ImGuiTextFilterPtr(ptr);
		public static implicit operator ImGuiTextFilter*(ImGuiTextFilterPtr nativePtr) => nativePtr.NativePtr;
		public bool IsActive()
		{
			var result = ImGuiNative.ImGuiTextFilterIsActive(NativePtr);
			return result != 0;
		}

		public void Clear()
		{
			ImGuiNative.ImGuiTextFilterClear(NativePtr);
		}

		public void Build()
		{
			ImGuiNative.ImGuiTextFilterBuild(NativePtr);
		}

		public bool PassFilter(ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* nativeText = text)
			fixed (byte* nativeTextEnd = textEnd)
			{
				var result = ImGuiNative.ImGuiTextFilterPassFilter(NativePtr, nativeText, nativeTextEnd);
				return result != 0;
			}
		}

		public bool PassFilter(ReadOnlySpan<char> text, ReadOnlySpan<char> textEnd)
		{
			// Marshaling text to native string
			byte* nativeText;
			var byteCountText = 0;
			if (text != null && !text.IsEmpty)
			{
				byteCountText = Encoding.UTF8.GetByteCount(text);
				if(byteCountText > Utils.MaxStackallocSize)
				{
					nativeText = Utils.Alloc<byte>(byteCountText + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountText + 1];
					nativeText = stackallocBytes;
				}
				var offsetText = Utils.EncodeStringUTF8(text, nativeText, byteCountText);
				nativeText[offsetText] = 0;
			}
			else nativeText = null;

			// Marshaling textEnd to native string
			byte* nativeTextEnd;
			var byteCountTextEnd = 0;
			if (textEnd != null && !textEnd.IsEmpty)
			{
				byteCountTextEnd = Encoding.UTF8.GetByteCount(textEnd);
				if(byteCountTextEnd > Utils.MaxStackallocSize)
				{
					nativeTextEnd = Utils.Alloc<byte>(byteCountTextEnd + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountTextEnd + 1];
					nativeTextEnd = stackallocBytes;
				}
				var offsetTextEnd = Utils.EncodeStringUTF8(textEnd, nativeTextEnd, byteCountTextEnd);
				nativeTextEnd[offsetTextEnd] = 0;
			}
			else nativeTextEnd = null;

			var result = ImGuiNative.ImGuiTextFilterPassFilter(NativePtr, nativeText, nativeTextEnd);
			// Freeing text native string
			if (byteCountText > Utils.MaxStackallocSize)
				Utils.Free(nativeText);
			// Freeing textEnd native string
			if (byteCountTextEnd > Utils.MaxStackallocSize)
				Utils.Free(nativeTextEnd);
			return result != 0;
		}

		public bool PassFilter(ReadOnlySpan<byte> text)
		{
			// defining omitted parameters
			byte* textEnd = null;
			fixed (byte* nativeText = text)
			{
				var result = ImGuiNative.ImGuiTextFilterPassFilter(NativePtr, nativeText, textEnd);
				return result != 0;
			}
		}

		public bool PassFilter(ReadOnlySpan<char> text)
		{
			// defining omitted parameters
			byte* textEnd = null;
			// Marshaling text to native string
			byte* nativeText;
			var byteCountText = 0;
			if (text != null && !text.IsEmpty)
			{
				byteCountText = Encoding.UTF8.GetByteCount(text);
				if(byteCountText > Utils.MaxStackallocSize)
				{
					nativeText = Utils.Alloc<byte>(byteCountText + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountText + 1];
					nativeText = stackallocBytes;
				}
				var offsetText = Utils.EncodeStringUTF8(text, nativeText, byteCountText);
				nativeText[offsetText] = 0;
			}
			else nativeText = null;

			var result = ImGuiNative.ImGuiTextFilterPassFilter(NativePtr, nativeText, textEnd);
			// Freeing text native string
			if (byteCountText > Utils.MaxStackallocSize)
				Utils.Free(nativeText);
			return result != 0;
		}

		/// <summary>
		/// Helper calling InputText+Build<br/>
		/// </summary>
		public bool Draw(ReadOnlySpan<byte> label, float width)
		{
			fixed (byte* nativeLabel = label)
			{
				var result = ImGuiNative.ImGuiTextFilterDraw(NativePtr, nativeLabel, width);
				return result != 0;
			}
		}

		/// <summary>
		/// Helper calling InputText+Build<br/>
		/// </summary>
		public bool Draw(ReadOnlySpan<char> label, float width)
		{
			// Marshaling label to native string
			byte* nativeLabel;
			var byteCountLabel = 0;
			if (label != null && !label.IsEmpty)
			{
				byteCountLabel = Encoding.UTF8.GetByteCount(label);
				if(byteCountLabel > Utils.MaxStackallocSize)
				{
					nativeLabel = Utils.Alloc<byte>(byteCountLabel + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountLabel + 1];
					nativeLabel = stackallocBytes;
				}
				var offsetLabel = Utils.EncodeStringUTF8(label, nativeLabel, byteCountLabel);
				nativeLabel[offsetLabel] = 0;
			}
			else nativeLabel = null;

			var result = ImGuiNative.ImGuiTextFilterDraw(NativePtr, nativeLabel, width);
			// Freeing label native string
			if (byteCountLabel > Utils.MaxStackallocSize)
				Utils.Free(nativeLabel);
			return result != 0;
		}

		/// <summary>
		/// Helper calling InputText+Build<br/>
		/// </summary>
		public bool Draw(ReadOnlySpan<byte> label)
		{
			// defining omitted parameters
			float width = 0.0f;
			fixed (byte* nativeLabel = label)
			{
				var result = ImGuiNative.ImGuiTextFilterDraw(NativePtr, nativeLabel, width);
				return result != 0;
			}
		}

		/// <summary>
		/// Helper calling InputText+Build<br/>
		/// </summary>
		public bool Draw(ReadOnlySpan<char> label)
		{
			// defining omitted parameters
			float width = 0.0f;
			// Marshaling label to native string
			byte* nativeLabel;
			var byteCountLabel = 0;
			if (label != null && !label.IsEmpty)
			{
				byteCountLabel = Encoding.UTF8.GetByteCount(label);
				if(byteCountLabel > Utils.MaxStackallocSize)
				{
					nativeLabel = Utils.Alloc<byte>(byteCountLabel + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountLabel + 1];
					nativeLabel = stackallocBytes;
				}
				var offsetLabel = Utils.EncodeStringUTF8(label, nativeLabel, byteCountLabel);
				nativeLabel[offsetLabel] = 0;
			}
			else nativeLabel = null;

			var result = ImGuiNative.ImGuiTextFilterDraw(NativePtr, nativeLabel, width);
			// Freeing label native string
			if (byteCountLabel > Utils.MaxStackallocSize)
				Utils.Free(nativeLabel);
			return result != 0;
		}

		/// <summary>
		/// Helper calling InputText+Build<br/>
		/// </summary>
		public bool Draw()
		{
			// defining omitted parameters
			float width = 0.0f;
			byte* nativeLabel = null;
			var byteCountLabel = Encoding.UTF8.GetByteCount("Filter(inc,-exc)");
			if(byteCountLabel > Utils.MaxStackallocSize)
			{
				nativeLabel = Utils.Alloc<byte>(byteCountLabel + 1);
			}
			else
			{
				var stackallocBytes = stackalloc byte[byteCountLabel + 1];
				nativeLabel = stackallocBytes;
			}
			var offsetNativeLabel = Utils.EncodeStringUTF8("Filter(inc,-exc)", nativeLabel, byteCountLabel);
			nativeLabel[offsetNativeLabel] = 0;
			var result = ImGuiNative.ImGuiTextFilterDraw(NativePtr, nativeLabel, width);
			if (byteCountLabel > Utils.MaxStackallocSize)
				Utils.Free(nativeLabel);
			return result != 0;
		}

		public void Destroy()
		{
			ImGuiNative.ImGuiTextFilterDestroy(NativePtr);
		}

		public void ImGuiTextFilterConstruct(ReadOnlySpan<byte> defaultFilter)
		{
			fixed (byte* nativeDefaultFilter = defaultFilter)
			{
				ImGuiNative.ImGuiTextFilterImGuiTextFilterConstruct(NativePtr, nativeDefaultFilter);
			}
		}

		public void ImGuiTextFilterConstruct(ReadOnlySpan<char> defaultFilter)
		{
			// Marshaling defaultFilter to native string
			byte* nativeDefaultFilter;
			var byteCountDefaultFilter = 0;
			if (defaultFilter != null && !defaultFilter.IsEmpty)
			{
				byteCountDefaultFilter = Encoding.UTF8.GetByteCount(defaultFilter);
				if(byteCountDefaultFilter > Utils.MaxStackallocSize)
				{
					nativeDefaultFilter = Utils.Alloc<byte>(byteCountDefaultFilter + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountDefaultFilter + 1];
					nativeDefaultFilter = stackallocBytes;
				}
				var offsetDefaultFilter = Utils.EncodeStringUTF8(defaultFilter, nativeDefaultFilter, byteCountDefaultFilter);
				nativeDefaultFilter[offsetDefaultFilter] = 0;
			}
			else nativeDefaultFilter = null;

			ImGuiNative.ImGuiTextFilterImGuiTextFilterConstruct(NativePtr, nativeDefaultFilter);
			// Freeing defaultFilter native string
			if (byteCountDefaultFilter > Utils.MaxStackallocSize)
				Utils.Free(nativeDefaultFilter);
		}

		public ImGuiTextFilterPtr ImGuiTextFilter(ReadOnlySpan<byte> defaultFilter)
		{
			fixed (byte* nativeDefaultFilter = defaultFilter)
			{
				return ImGuiNative.ImGuiTextFilterImGuiTextFilter(nativeDefaultFilter);
			}
		}

		public ImGuiTextFilterPtr ImGuiTextFilter(ReadOnlySpan<char> defaultFilter)
		{
			// Marshaling defaultFilter to native string
			byte* nativeDefaultFilter;
			var byteCountDefaultFilter = 0;
			if (defaultFilter != null && !defaultFilter.IsEmpty)
			{
				byteCountDefaultFilter = Encoding.UTF8.GetByteCount(defaultFilter);
				if(byteCountDefaultFilter > Utils.MaxStackallocSize)
				{
					nativeDefaultFilter = Utils.Alloc<byte>(byteCountDefaultFilter + 1);
				}
				else
				{
					var stackallocBytes = stackalloc byte[byteCountDefaultFilter + 1];
					nativeDefaultFilter = stackallocBytes;
				}
				var offsetDefaultFilter = Utils.EncodeStringUTF8(defaultFilter, nativeDefaultFilter, byteCountDefaultFilter);
				nativeDefaultFilter[offsetDefaultFilter] = 0;
			}
			else nativeDefaultFilter = null;

			var result = ImGuiNative.ImGuiTextFilterImGuiTextFilter(nativeDefaultFilter);
			// Freeing defaultFilter native string
			if (byteCountDefaultFilter > Utils.MaxStackallocSize)
				Utils.Free(nativeDefaultFilter);
			return result;
		}

		public ImGuiTextFilterPtr ImGuiTextFilter()
		{
			// defining omitted parameters
			byte* nativeDefaultFilter = null;
			var byteCountDefaultFilter = Encoding.UTF8.GetByteCount("");
			if(byteCountDefaultFilter > Utils.MaxStackallocSize)
			{
				nativeDefaultFilter = Utils.Alloc<byte>(byteCountDefaultFilter + 1);
			}
			else
			{
				var stackallocBytes = stackalloc byte[byteCountDefaultFilter + 1];
				nativeDefaultFilter = stackallocBytes;
			}
			var offsetNativeDefaultFilter = Utils.EncodeStringUTF8("", nativeDefaultFilter, byteCountDefaultFilter);
			nativeDefaultFilter[offsetNativeDefaultFilter] = 0;
			var result = ImGuiNative.ImGuiTextFilterImGuiTextFilter(nativeDefaultFilter);
			if (byteCountDefaultFilter > Utils.MaxStackallocSize)
				Utils.Free(nativeDefaultFilter);
			return result;
		}

	}
}
